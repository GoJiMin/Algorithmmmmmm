const input = require("fs")
  .readFileSync(process.platform === "linux" ? "/dev/stdin" : "input.txt")
  .toString()
  .trim();

/**
 * 1 2 3 더하기 문제랑 약간 비슷한가? 싶기는 한데..
 *
 * 1의 제곱수 항의 최소 개수는 1.
 * 2의 제곱수 항의 최소 개수는 1.
 * 3의 제곱수 항의 최소 개수는 1.
 *
 * 인데요. 그냥 11을 두고 생각해보면 11의 제곱수 항을 어떻게 표현해볼 수 있을까요?
 * 1, 2, 3의 제곱수로 이루어져있겠네요 4는 제곱하면 16이라 범위를 넘어가니까요..
 *
 * 자 그럼 이제 위의 제곱수들을 이용해 아래와 같이 표현해볼 수 있겠네요.
 * 11 = 10 + 1 ** 2 => 10 + 1
 * 11 = 7 + 2 ** 2  => 7 + 4
 * 11 = 2 + 3 ** 2  => 2 + 9
 *
 * 그럼 여기서 제곱수 본인들을 제외한 10, 7, 2를 또 제곱수 항으로 나타내면요?
 *
 * 11 = 2 + 3 ** 2 => 2 + 9 => 2의 제곱수 항의 최소 개수는 1개니까 3최소 개수는 2개겠죠?
 *
 * 이런식으로 풀어보면 되겠네요.. 그럼 DP의 각 테이블은 해당 수를 이루는 제곱수 항의 최소 개수로 두면 되겠죠?
 * 그럼 점화식은..
 *
 * DP[i] = DP[i - k ** 2] + 1일텐데 최소 개수를 구해야되죠? 위에서 가능한 모든 제곱수들을 탐색하니까요.
 * 그럼..
 *
 * DP[i] = min(DP[i], DP[i - k ** 2] + 1) 이겠네요..
 */

const N = Number(input);

const DP = Array(N + 1).fill(Infinity);

DP[0] = 0; // Base Case...

for (let i = 1; i <= N; i++) {
  // i를 이루는 제곱수만 허용하기 위해서...
  for (let j = 1; j * j <= i; j++) {
    DP[i] = Math.min(DP[i], DP[i - j * j] + 1);
  }
}

console.log(DP[N]);
