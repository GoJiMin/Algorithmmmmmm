const input = require("fs")
  .readFileSync(process.platform === "linux" ? "/dev/stdin" : "input.txt")
  .toString()
  .trim()
  .split("\n");

/**
 * 벌써 20분째 고민 중인데.. 어떻게 풀지 감이 안 잡히네요..
 *
 * 약간 예제를 임의로 바꿔서 생각해봅시다..
 *
 * 7
 * 35 40 50 10 30 45 60은 똑같이 두고.. x를 1로 바꿔봅시다..
 * 그럼 45, 50, 60을 골라야겠죠? 흠..
 *
 * 어? 이거 누적합 + DP?
 * [35, 75, 125, 135, 165, 210, 270] 일단 누적시킨 배열..
 *
 * 일단 소형 기관차가 3대니까 DP 테이블을 dp[i][j]로 정의한다면,
 * i번째 객체를 선택했을 때, 소형기관차를 j대 사용했을 때 승객의 수로 계산하면 되지 않을까요?
 *
 * 그럼 i번째.. 즉, 우리가 현재 객차를 선택하지 않는다면 값을 어떻게 설정할까요..?
 * 그냥 i - 1번째 값을 그대로 가져오면 되겠죠? 선택하지 않으니까요..
 * 그럼 dp[i - 1][j]
 *
 * 그럼 다른 예로 i번째에 소형 기관차 한대를 새로 배치한다면요?
 * 그럼 우리는 j - 1개의 기관차를 끌었을 때의 점수가 필요하고,
 * 문제에서 기관차는 최대 x칸만큼 끌 수 있다고 했죠? 그럼 i - x칸에서 이어줄 수 있겠죠?
 * dp[i - x][j - 1]에 우리가 현재 끌 수 있는 승객의 수를 더할 수 있을 거 같은데요.
 * 구간합은 그냥 prefix[i] - prefix[i - x - 1]이죠?
 * 그럼 dp[i - x][j - 1] + prefix[i] - prefix[i - x - 1]
 * 이렇게 나오죠? 그럼 객차를 선택하거나 혹은 객차를 버린 쪽과 비교해 이득인 쪽을 선택하면 될 거 같은데요.
 *
 * dp[i][j] = max(dp[i - 1][j], dp[i - x][j - 1] + prefix[i] - prefix[i - x - 1]) ?
 */

const n = Number(input[0]); // 기차가 끌고 가던 객차의 수.
const arr = input[1].split(" ").map(Number); // 각 기차의 손님 수. 1번 객차부터 차례로 입력됨.
const x = Number(input[2]); // 소형 기관차가 최대로 끌 수 있는 객차의 수.

for (let i = 1; i < n; i++) arr[i] = arr[i] + arr[i - 1];

const dp = Array.from({ length: n + 1 }, () => Array(4).fill(0));

/**
 * 자 우선 j = 1.. 소형 기관차를 1대만 운용했을 때의 경우를 봅시다.
 * i는 최소한 우리가 소형 기관차를 운용한다면 x칸 만큼 운용을 해야하니까요? 현재 예시는 2칸씩 움직일 수 있으니 봅시다.
 * dp[2][1] = max(dp[1][1], dp[0][0] + arr[1] - arr[-1])이 나오죠?
 * 풀어서 생각해보면 1대를 사용했을 때의 경우로 보고, dp[1][1]은요? 그냥 패스입니다 우리 2칸씩 끌 건데 1칸만 쓰잖아요?
 * 마찬가지로 dp[0][0]은 0칸을 0개의 소형기관차로 끌면 승객의 수는 0명이니 넘어가고,
 * arr[1]은 승객 2칸의 구간합이니 75.. 즉, 소형 기관차 1대로 2번째 승객칸을 바라볼 때, 우리는 딱 2칸 끌어가니까 75명 태우죠?
 * 다음으로 dp[3][1] = max(dp[2][1], dp[1][0] + arr[2] - arr[0])
 * 3칸째에 1명으로 끌었을 때, 최대 승객 수는 고르지 않거나 (75), 1칸째에 0개의 소형기관차 0명 + 구간합 125 - 35 = 90
 * 쭉쭉 가고, 다음으로 소형 기관차 2대를 끌 때 봅시다.
 *
 * 이제 여기서 좀 오래 걸렸는데, 우리가 2대를 끈다는건 적어도 앞에 1대가 있다는 거잖아요? 그럼 즉, x가 2일 때, 2대 째라면,
 * 앞에 4칸 중에 1개의 소형 기관차로 끌고 갈 수 있잖아요? 그러니까 i의 시작점은 j * x로 4부터 시작합니다.
 *
 * dp[4][2]는요 dp[3][2]는 0이죠? dp[2][1] 2칸째에 1칸으로 끌어가던 승객 수에 현재 구간합인 arr[3] - arr[1]를 붙여갈 수 있겠죠?
 *
 * 근데 i - x - 1에 대한 예외처리만 해주면 되겠네요.
 */
for (let j = 1; j <= 3; j++) {
  for (let i = j * x; i <= n; i++) {
    dp[i][j] = Math.max(
      dp[i - 1][j],
      dp[i - x][j - 1] + arr[i - 1] - (i - x - 1 < 0 ? 0 : arr[i - x - 1])
    );
  }
}

console.log(dp[n][3]);
