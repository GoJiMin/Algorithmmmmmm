const input = require("fs")
  .readFileSync(process.platform === "linux" ? "/dev/stdin" : "input.txt")
  .toString()
  .trim()
  .split("\n");

/**
 * 솔직히 이 문제 이해하고 푸는데 너무 어려웠습니다..
 *
 * DP로 풀 수 있는게 맞나? 싶기도 하고..
 *
 * 우선 정사각형은 모든 변의 길이가 같아야 됩니다.. 그쵸?
 * 예제 입력 1의 경우 가운데 모든 변의 길이가 2인 정사각형이 존재하구요.
 *
 * 그럼 예제 입력 배열의 (2, 2) 위치는 1입니다. 그럼 이 위치 자체로는 모든 변의 길이가 1인 정사각형이죠?
 * 그럼 이 정사각형을 확장하려면 어떻게 해야될까요?
 *
 * 왼쪽, 왼쪽 위의 대각선, 바로 위. 이 위치가 모두 정사각형이라면 확장해서 모든 변의 길이가 2인 정사각형을 만들 수 있겠네요.
 *
 * 이 생각을 가지고 DP로 풀 수 있는데요..
 *
 * 자 그럼 우리는 왼쪽, 왼쪽 위 대각선, 바로 위가 모두 정사각형임을 보장해야만 확장할 수 있습니다.
 *
 * 그럼 DP 배열을 2차원으로 선언하고 아래의 점화식을 세울 수 있습니다.
 * DP[i][j] = min(DP[i][j - 1], DP[i - 1], [j - 1], DP[i - 1][j]) + 1
 *
 * 왼쪽, 왼쪽 위 대각선, 바로 위가 하나라도 정사각형이 아니라면 확장할 수 없게 됩니다.
 * (2, 1)의 위치를 볼까요? 이 위치는 정사각형이므로 확장할 수 있는지 확인합니다.
 * DP[2][1] = min(1, 1, 0) + 1 => 1 이렇게 왼쪽 위 대각선이 정사각형이 아니기 때문에 확장할 수 없어 1이 되겠네요.
 *
 * 근데 이렇게 점화식을 세우면 1행과 1열에 대해서는 예외 처리를 해줘야되니 먼저 돌려놓고 시작하면 되겠습니다.
 *
 * 어차피 n, m이 1000까지라 충분할 거 같네요.
 */

const [n, m] = input[0].split(" ").map(Number);

const board = [];

for (let i = 1; i <= n; i++) {
  board.push(input[i].trim().split(""));
}

const dp = Array.from({ length: n }, () => Array(m).fill(0));

let max = 0;

for (let i = 0; i < n; i++) {
  for (let j = 0; j < m; j++) {
    if (board[i][j] === "1" && (i === 0 || j === 0)) {
      dp[i][j] = 1;
    } else if (board[i][j] === "1") {
      dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j - 1], dp[i - 1][j]) + 1;
    }

    max = Math.max(dp[i][j], max);
  }
}

console.log(max * max);
